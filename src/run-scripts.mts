import process from "node:process";
import fs from "node:fs";
import playwright from "playwright";

type BrowserKey = "chromium" | "firefox" | "webkit";

type JourneyResultFailure = {
  result: "failure";
  traceFilePath: string;
  failureReason: unknown;
  input: any;
  browserKey: BrowserKey;
};
type JourneyResultSuccess = {
  result: "success";
  traceFilePath: string;
  input: any;
  browserKey: BrowserKey;
};
export type JourneyResult = JourneyResultFailure | JourneyResultSuccess;

export async function runJourney<
  JourneyInputKey extends string,
  JourneyInput extends { [key in JourneyInputKey]: string }
>({
  journeyInputKey,
  inputs,
  browsersToRunOn,
  playwrightLaunchOptions,
  diffOptions,
  journey,
  postProcessJourneyTrace,
}: {
  journeyInputKey: JourneyInputKey;
  inputs: JourneyInput[];
  browsersToRunOn: BrowserKey[];
  playwrightLaunchOptions?: playwright.LaunchOptions;
  diffOptions?: {
    /**
     * Directory to store traces in.
     *
     * @defualt process.cwd()
     */
    traceDir?: string;
  };
  /**
   * Runs a journey and records a trace.
   *
   * @returns {object} metadata to be attached to the generated journey trace.
   */
  journey: ({
    page,
    input,
  }: {
    page: playwright.Page;
    input: JourneyInput;
  }) => Promise<object>;
  /**
   * Optional step to process traces generated by the journey,
   * when provided -- generated traces are cleaned up by default.
   *
   * ```ts
   * postProcessJourneyTrace({traceFilePath}) {
   *   const zipObject = await jszip.loadAsync();
   *   // do something with trace contents
   * }
   * ```
   */
  postProcessJourneyTrace?: ({
    traceFilePath,
    input,
  }: {
    traceFilePath: string;
    input: JourneyInput;
    journeyResult: JourneyResult;
  }) => Promise<void>;
}) {
  let browsers: { [browserKey in BrowserKey]?: playwright.Browser } = {};

  let journeyResults: JourneyResult[] = [];

  const tracesDir = diffOptions?.traceDir ?? `${process.cwd()}/traces`;

  if (!fs.existsSync(tracesDir)) {
    fs.mkdirSync(tracesDir);
  }

  for (const input of inputs) {
    for (const browserKey of browsersToRunOn) {
      browsers[browserKey] ??= await playwright[browserKey].launch(
        playwrightLaunchOptions
      );
      const context = await browsers[browserKey]!.newContext();
      await context.tracing.start({ screenshots: true, snapshots: true });

      const page = await context.newPage();

      let journeyResult: JourneyResult;

      const traceFilePath = `${tracesDir}/${input[journeyInputKey]}-${browserKey}.zip`;

      try {
        await journey({
          page,
          input,
        });

        journeyResult = {
          result: "success",
          input,
          traceFilePath,
          browserKey,
        };
      } catch (err) {
        journeyResult = {
          result: "failure",
          input,
          failureReason: err,
          traceFilePath,
          browserKey,
        };
      }
      // Take a final screenshot so it's in the trace file
      await page.screenshot();
      await context.tracing.stop({
        path: traceFilePath,
      });
      await page.close();
      await context.close();
      journeyResults.push(journeyResult);
    }
  }

  for (const activeBrowser of Object.keys(browsers)) {
    await browsers[activeBrowser as BrowserKey]!.close();
  }

  fs.writeFileSync(
    tracesDir + "/journeys.json",
    JSON.stringify(journeyResults, null, 2)
  );

  if (postProcessJourneyTrace) {
    for (const journeyResult of journeyResults) {
      await postProcessJourneyTrace({
        traceFilePath: journeyResult.traceFilePath,
        input: journeyResult.input,
        journeyResult,
      });
    }
  }
}
